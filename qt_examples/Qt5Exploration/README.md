# Достоинства/недостатки Qt 5 для мобильных приложений

Сильными сторонами Qt 5, в части разработки приложений для мобильных устройств являются:
1. Можно использовать актуальные версии существующих библиотек на C++. Как пример - достаточно легко подключить **свежую версию OpenSSL** и закрыть уязвимости в криптографической подсистеме. В случае мобильных платформ это особенно актуально, т.е. Java-приложения используют сетевой уровень операционной системы и если Android/iOS не обновляется систематически, уязвимости могут быть сохранены. Для таких приложений, как мобильный банк и криптовалютная биржа - иметь возможность управлять устранением уязвимостей в сетевой инфраструктуре - критически важно
2. Мощный язык описания композиции элементов пользовательского интерфейса **QML**. Большое число анимационных эффектов позволяют разрабатывать более насыщенный и привлекательный пользовательский интерфейс, чем у типовых Android/iOS приложений, разработанных с использованием Platform SDK
3. Использование C++ позволяет реализовывать алгоритмы с высокой вычислительной сложностью, потребляющие меньшее количество энергии, чем приложения, разработанные на managed языках (Java, Swift). Следует учитывать, что в приложениях на Platform SDK может быть использован Native-код (С++)
4. Один и тот же код может быть использован как для сборки приложения под Android, так и под iOS. Единственный нюанс - не следует переоценивать возможность "*универсальной сборки*" - они сильно ограничены
5. Activity Lifecycle в Android имеет значимые особенности функционирования и, например, при повороте экрана Activity может быть удалён, а затем пересоздан. В этом случае, содержимое EditText сохраниться (оно автоматически помещается в кэш при удалении/восстановлении Activity), а содержимое TextView будет потеряно. Чтобы избежать потери данных, необходимо вручную сохранять в Bundle, восстанавливать из Bundle (см. Persist Data). В случае QML - эта работа выполняется движком QML и программисту не нужно об этом думать
6. Чтобы избежать дублирования http-запросов в Java-приложении необходимо использовать специализированные подходы, такие как использование **AsyncTaskLoader**. В Qt-приложении можно реализовать сетевое взаимодействие в коде на C++ традиционным образом - в отдельном рабочем потоке, никак не связанном в удаляемой/пересоздаваемой Activity. Единственный важный нюанс - коммуникационная подсистема должна работать таким образом, чтобы при выполнении запросов менялось общее состояние приложения (AppState) релевантным с QML-кодом образом. Например, при выполнении запроса меняется некоторый атрибут, что приводит к возникновению сигнала обрабатываемого в QML-коде и соответствующим образом корректирующим пользовательский интерфейс.

Недостатки Qt 5 при разработке мобильных приложений:
1. Технологический stack гораздо более сложный. Часть кода разрабатывается на Platform SDK (Java/Kotlin/Swift), а часть на C++, QML и JavaScript. Настройка инструментальных средств сложнее, чем в случае использования Xcode, или Android Studio
2. Разные целевые платформы поддерживают разные подмножества Qt API. Например, Qt Multimedia Widgets не поддерживаются на Android, а под iOS нельзя получить информацию о видимых спутниках GPS
3. Необходимо совмещать в apk-файле код для разных аппаратных платформ, либо создавать разные packages для разных аппаратных платформ (ARM и x86). Проблема актуальна только для Android
4. Добавление Qt-библиотек ощутимо увеличивает размер apk-файлов
5. При необходимости использования Platform Specific-функций, например, для доступа к хранилищу изображений, необходимо разрабатывать интеграционный слой с использованием JNI и наследованием QML Activity в Java-коде, Java-классом. Это существенно повышает сложность приложения.

# Qt5Exploration 

В данном репозитарии хранится приложение, в котором решаются *пограничные* задачи, такие как взаимодействие C++ и JavaScript-кода (QML) в приложении на Qt5.

**Задача**: реализовать обмен сообщениями через **Signals and Slots** кода на **C++** и **QML**.

**Подзадачи**:
1. Обеспечить выполнение connect() внутри компонента QML через свойство
2. Обеспечить обмен сигналами через код на C++
3. Обеспечить передачу данных из кода на C++ в список в QML, посредством QAbstractListModel
4. Выполнить https-запрос и разобрать полученный JSON-ответ

# Выполнение http/https-запросов

Ключевым классом, обеспечивающим возможность выполнения http(s)-запросов является **QNetworkAccessManager**. Через экземпляр этого класса можно запускать запрос на выполнение, например, так:

```cpp
QNetworkReply *networkReply = manager->get(request);
```

Для того, чтобы выполнять подключение по **SSL/TLS** необходимо указать SSL-конфигурацию, в которой можно настроить сертификаты:

```cpp
QNetworkRequest request;

request.setUrl(QUrl("https://restcountries.eu/rest/v2/all"));
request.setSslConfiguration(QSslConfiguration::defaultConfiguration());
```

Необходимо добавить динамические библиотеки из состава [OpenSSL](https://www.openssl.org/). Их можно собрать самостоятельно из исходных текстов, либо загрузить из доверенного источника (я использовал - https://indy.fulgan.com/SSL/). Необходимо учитывать разрядность библиотек (**x64, x32**). Названия требуемых библиотек: **libeay32.dll** и **ssleay32.dll**

## Изменения в Qt API

При портировании приложения с Qt 5.12 на 5.15 столкнулся к проблемой "deprecated call". Было:

```cpp
connect(networkReply, QOverload<QNetworkReply::NetworkError>::of(&QNetworkReply::error),
    this, &MyQmlProxyClass::networkReplyError);
```

Эквивалентный код в Qt 5.15:

```cpp
connect(networkReply, &QNetworkReply::errorOccurred, this, &MyQmlProxyClass::networkReplyError);
```

Код, несомненно, стал более компактным и читается легче, но при переходе на новую подверсию, код пришлось изменять.

## Подключение openSSL

Корпорация Google запретила использование http в Android и подключение openSSL стало безальтернативным. При этом, в новые SDK включены бинарные библиотеки openSSL и их уже не нужно собирать вручную. Теперь достаточно модификация pro-файла:

```
HEADERS += \
    myhttpservice.h \
    ...
android: include(C:/Android_SDK/android_openssl/openssl.pri)
```
